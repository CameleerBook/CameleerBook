<!DOCTYPE html><html><head><title>linkedlist.ml</title><style>span {tab-size: 2;} .logical { color:rgb(244, 157, 55); } .keyword { color: red; } .contract { color: #1069B3; } .comment { color: #666666; } .number { color: black; }.info { border-top: 1px solid black; }.title { border-bottom: 1px solid black; }</style></head><body><div class="title"><h2>Linked List<h2></div><pre>
<span class="comment">(* Implementation by Pedro Gasparinho, advised by Mário Pereira *)</span>
<span class="comment">(* Specification by Pedro Gasparinho, advised by Mário Pereira *)</span>

<span class="keyword">module</span> <span class="keyword">type</span> Cmp = <span class="keyword">sig</span>
	<span class="keyword">type</span> t

	<span class="keyword">val</span> eq: t -> t -> <span class="keyword">bool</span> [@@logic]
	<span class="contract">(*@ b = eq x y
		<span class="logical">ensures</span> b &lt;-> x = y *)</span>
	
<span class="keyword">end</span>

<span class="keyword">module</span> LinkedList (E: Cmp) = <span class="keyword">struct</span>

  <span class="keyword">type</span> elt = E.t
  <span class="keyword">type</span> llist = Nil | Cons <span class="keyword">of</span> elt * llist

  <span class="contract">(*@ <span class="logical">function</span> <span class="logical">rec</span> logic_len (l: llist) : <span class="logical">int</span> =
      <span class="logical">match</span> l <span class="logical">with</span>
      | Nil -> 0
      | Cons _ t -> 1 + logic_len t *)</span>
  <span class="contract">(*@ <span class="logical">variant</span> l 
      <span class="logical">ensures</span> l = Nil -> result = 0
      <span class="logical">ensures</span> l &lt;> Nil -> result > 0 *)</span>

  <span class="keyword">let</span> len l = 
    <span class="keyword">let</span> <span class="keyword">rec</span> aux c = <span class="keyword">function</span>
      | Nil -> c
      | Cons (_, t) -> aux (c+1) t
    <span class="contract">(*@ r = aux c s
        <span class="logical">variant</span> s
        <span class="logical">ensures</span> c + logic_len s = r *)</span>
    <span class="keyword">in</span> aux 0 l
  <span class="contract">(*@ r = len l
      <span class="logical">ensures</span> r = logic_len l *)</span>

  <span class="keyword">let</span> is_empty l =
    len l = 0
  <span class="contract">(*@ r = is_empty l 
      <span class="logical">ensures</span> r &lt;-> l = Nil *)</span>

  <span class="keyword">let</span>[@logic] <span class="keyword">rec</span> get l n = 
    <span class="keyword">match</span> l <span class="keyword">with</span>
    | Nil -> <span class="keyword">assert</span> <span class="keyword">false</span>
    | Cons (h, t) -> 
      <span class="keyword">if</span> n = 0 <span class="keyword">then</span> h 
      <span class="keyword">else</span> get t (n-1)
  <span class="contract">(*@ r = get l n
      <span class="logical">variant</span> n
      <span class="logical">requires</span> 0 &lt;= n &lt; logic_len l *)</span>

  <span class="keyword">let</span>[@logic] <span class="keyword">rec</span> mem x l =
		<span class="keyword">match</span> l <span class="keyword">with</span>
		| Nil -> <span class="keyword">false</span>
		| Cons (h, t) -> E.eq h x || mem x t
  <span class="contract">(*@ r = mem x l
      <span class="logical">variant</span> l *)</span>

  <span class="contract">(*@ <span class="logical">predicate</span> reverse (l1 l2: llist) = 
      logic_len l1 = logic_len l2 &amp;&amp; <span class="logical">forall</span> i. 
      0 &lt;= i &lt; logic_len l1 -> get l1 i = get l2 (logic_len l1 - 1 - i) *)</span>

  <span class="keyword">let</span>[@logic] rev l =
    <span class="keyword">let</span> <span class="keyword">rec</span> aux acc = <span class="keyword">function</span>
      | Nil -> acc
      | Cons (h, t) -> aux (Cons (h, acc)) t
    <span class="contract">(*@ r = aux acc s
        <span class="logical">ensures</span> logic_len r = logic_len acc + logic_len s 
        <span class="logical">ensures</span> <span class="logical">forall</span> i. 0 &lt;= i &lt; logic_len s -> 
          E.eq (get r i) (get s (logic_len s - 1 - i))
        <span class="logical">ensures</span> <span class="logical">forall</span> i. logic_len s &lt;= i &lt; logic_len r -> 
          E.eq (get r i) (get acc (i - logic_len s)) 
        <span class="logical">variant</span> s *)</span>
    <span class="keyword">in</span> aux Nil l
  <span class="contract">(*@ r = rev l
      <span class="logical">ensures</span> logic_len r = logic_len l
      <span class="logical">ensures</span> reverse r l *)</span>

  <span class="contract">(*@ <span class="logical">predicate</span> appended (r l1 l2: llist) =
      logic_len r = logic_len l1 + logic_len l2 &amp;&amp;
      <span class="logical">forall</span> i. 0 &lt;= i &lt; logic_len l1 -> get r i = get l1 i &amp;&amp;
      <span class="logical">forall</span> i. logic_len l1 &lt;= i &lt; logic_len l1 + logic_len l2 ->
        get r i = get l2 (i - logic_len l1) *)</span>

  <span class="keyword">let</span>[@logic] append l1 l2 =
    <span class="keyword">let</span> <span class="keyword">rec</span> aux s1 s2 =
      <span class="keyword">match</span> s1 <span class="keyword">with</span>
      | Nil -> s2
      | Cons (h, t) -> aux t (Cons (h, s2)) 
    <span class="contract">(*@ r = aux s1 s2
        <span class="logical">variant</span> s1
        <span class="logical">ensures</span> logic_len r = logic_len s1 + logic_len s2
        <span class="logical">ensures</span> <span class="logical">forall</span> i. 0 &lt;= i &lt; logic_len s1 -> 
          get r i = get s1 (logic_len s1 - 1 - i)
        <span class="logical">ensures</span> <span class="logical">forall</span> i. logic_len s1 &lt;= i &lt; logic_len s1 + logic_len s2 ->
          get r i = get s2 (i - logic_len s1) *)</span>
    <span class="keyword">in</span> <span class="keyword">let</span> r1 = rev l1 <span class="keyword">in</span> aux r1 l2
  <span class="contract">(*@ r = append l1 l2
      <span class="logical">ensures</span> appended r l1 l2 *)</span>

	<span class="keyword">let</span> map f l =
		<span class="keyword">let</span> <span class="keyword">rec</span> aux acc f = <span class="keyword">function</span>
			| Nil -> acc
			| Cons (h, t) -> aux (Cons (f h, acc)) f t
		<span class="contract">(*@ r = aux acc f s
				<span class="logical">variant</span> s
				<span class="logical">ensures</span> logic_len r = logic_len acc + logic_len s
        <span class="logical">ensures</span> <span class="logical">forall</span> i. 0 &lt;= i &lt; logic_len s -> 
          E.eq (get r i) (f (get s (logic_len s - 1 - i)))
        <span class="logical">ensures</span> <span class="logical">forall</span> i. logic_len s &lt;= i &lt; logic_len r -> 
          E.eq (get r i) (get acc (i - logic_len s)) *)</span>
		<span class="keyword">in</span> <span class="keyword">let</span> l' = rev l <span class="keyword">in</span> aux Nil f l'	
	<span class="contract">(*@ r = map f l
			<span class="logical">ensures</span> logic_len r = logic_len l
			<span class="logical">ensures</span> <span class="logical">forall</span> i. 0 &lt;= i &lt; logic_len l -> E.eq (f (get l i)) (get r i) *)</span>

	<span class="keyword">let</span> filter f l =
		<span class="keyword">let</span> <span class="keyword">rec</span> aux acc f = <span class="keyword">function</span>
			| Nil -> acc
			| Cons (h, t) -> 
				<span class="keyword">if</span> f h <span class="keyword">then</span> aux (Cons (h, acc)) f t
				<span class="keyword">else</span> aux acc f t 
		<span class="contract">(*@ r = aux acc f s 
				<span class="logical">variant</span> s
				<span class="logical">requires</span> <span class="logical">forall</span> x: elt. mem x acc -> f x
				<span class="logical">ensures</span> 0 &lt;= logic_len r &lt;= logic_len acc + logic_len s
				<span class="logical">ensures</span> <span class="logical">forall</span> x: elt. mem x r -> f x
				<span class="logical">ensures</span> <span class="logical">forall</span> i. 0 &lt;= i &lt; logic_len r -> 
					<span class="logical">exists</span> i'. i &lt;= i' &lt; logic_len s -> 
					E.eq (get r i) (get s i')
				<span class="logical">ensures</span> <span class="logical">forall</span> i j. 0 &lt;= i &lt;= j &lt; logic_len r -> 
					<span class="logical">exists</span> i' j'. i &lt;= i' &lt;= j' &lt; logic_len s ->
					E.eq (get r i) (get s i') &amp;&amp; E.eq (get r j) (get s j') *)</span>	
		<span class="keyword">in</span> <span class="keyword">let</span> l' = rev l <span class="keyword">in</span> aux Nil f l'
	<span class="contract">(*@ r = filter f l
			<span class="logical">ensures</span> 0 &lt;= logic_len r &lt;= logic_len l
			<span class="logical">ensures</span> <span class="logical">forall</span> x: elt. mem x r -> f x 
			<span class="logical">ensures</span> <span class="logical">forall</span> i. 0 &lt;= i &lt; logic_len r -> 
				<span class="logical">exists</span> i'. i &lt;= i' &lt; logic_len l -> 
				E.eq (get r i) (get l i')
			<span class="logical">ensures</span> <span class="logical">forall</span> i j. 0 &lt;= i &lt;= j &lt; logic_len r -> 
				<span class="logical">exists</span> i' j'. i &lt;= i' &lt;= j' &lt; logic_len l ->
				E.eq (get r i) (get l i') &amp;&amp; E.eq (get r j) (get l j') *)</span>

  <span class="comment">(*let find x l =
    let rec aux acc x = function
      | Nil -> -1
      | Cons (h, t) -> 
        if E.eq x h then len acc
        else aux (Cons (h, acc)) x t
    (*@ r = aux acc x s 
        variant s
        requires 0 &lt;= logic_len acc &lt;= logic_len l
        requires logic_len l = logic_len acc + logic_len s
        requires append (rev acc) s = l
        ensures -1 &lt;= r &lt; logic_len l
        ensures r = -1 -> forall i. 0 &lt;= i &lt; logic_len acc -> not (E.eq (get s i) x)
        ensures r >= 0 -> E.eq (get s r) x *)
    in aux Nil x l
  (*@ r = find x l
      ensures -1 &lt;= r &lt; logic_len l
      ensures r = -1 -> forall i. 0 &lt;= i &lt; logic_len l -> not (E.eq (get l i) x)
      ensures r >= 0 -> E.eq (get l r) x *)*)</span>

	<span class="comment">(* 
				ensures forall i. 0 &lt;= i &lt; logic_len r -> 
				exists i'. i &lt;= i' &lt; logic_len s -> 
				E.eq (get r i) (get s i')
			ensures forall i j. 0 &lt;= i &lt;= j &lt; logic_len r -> 
				exists. i' j'. i &lt;= i' &lt;= j' &lt; logic_len s ->
				E.eq (get r i) (get s i') &amp;&amp; E.eq (get r j) (get s j')
	
	*)</span>	

<span class="keyword">end</span></pre>
<div class="info">
<p>This page was generated with <a href="https://github.com/PedroGasparinho/Cameleer2Html">Cameleer2Html</a><p>
</div>
</body></html>
